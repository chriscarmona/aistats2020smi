// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include "../inst/include/aistats2020smi.h"
#include <RcppArmadillo.h>
#include <Rcpp.h>
#include <string>
#include <set>

using namespace Rcpp;

// SMI_post_biased_data
Rcpp::List SMI_post_biased_data(const arma::vec Z, const arma::vec Y, const double sigma_z, const double sigma_y, const double sigma_phi, const double sigma_theta, const double sigma_theta_tilde, const double eta);
static SEXP _aistats2020smi_SMI_post_biased_data_try(SEXP ZSEXP, SEXP YSEXP, SEXP sigma_zSEXP, SEXP sigma_ySEXP, SEXP sigma_phiSEXP, SEXP sigma_thetaSEXP, SEXP sigma_theta_tildeSEXP, SEXP etaSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::vec >::type Z(ZSEXP);
    Rcpp::traits::input_parameter< const arma::vec >::type Y(YSEXP);
    Rcpp::traits::input_parameter< const double >::type sigma_z(sigma_zSEXP);
    Rcpp::traits::input_parameter< const double >::type sigma_y(sigma_ySEXP);
    Rcpp::traits::input_parameter< const double >::type sigma_phi(sigma_phiSEXP);
    Rcpp::traits::input_parameter< const double >::type sigma_theta(sigma_thetaSEXP);
    Rcpp::traits::input_parameter< const double >::type sigma_theta_tilde(sigma_theta_tildeSEXP);
    Rcpp::traits::input_parameter< const double >::type eta(etaSEXP);
    rcpp_result_gen = Rcpp::wrap(SMI_post_biased_data(Z, Y, sigma_z, sigma_y, sigma_phi, sigma_theta, sigma_theta_tilde, eta));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _aistats2020smi_SMI_post_biased_data(SEXP ZSEXP, SEXP YSEXP, SEXP sigma_zSEXP, SEXP sigma_ySEXP, SEXP sigma_phiSEXP, SEXP sigma_thetaSEXP, SEXP sigma_theta_tildeSEXP, SEXP etaSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_aistats2020smi_SMI_post_biased_data_try(ZSEXP, YSEXP, sigma_zSEXP, sigma_ySEXP, sigma_phiSEXP, sigma_thetaSEXP, sigma_theta_tildeSEXP, etaSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// SMI_pred_biased_data
Rcpp::List SMI_pred_biased_data(const arma::vec Z, const arma::vec Y, const double sigma_z, const double sigma_y, const double sigma_phi, const double sigma_theta, const double sigma_theta_tilde, const double eta);
static SEXP _aistats2020smi_SMI_pred_biased_data_try(SEXP ZSEXP, SEXP YSEXP, SEXP sigma_zSEXP, SEXP sigma_ySEXP, SEXP sigma_phiSEXP, SEXP sigma_thetaSEXP, SEXP sigma_theta_tildeSEXP, SEXP etaSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::vec >::type Z(ZSEXP);
    Rcpp::traits::input_parameter< const arma::vec >::type Y(YSEXP);
    Rcpp::traits::input_parameter< const double >::type sigma_z(sigma_zSEXP);
    Rcpp::traits::input_parameter< const double >::type sigma_y(sigma_ySEXP);
    Rcpp::traits::input_parameter< const double >::type sigma_phi(sigma_phiSEXP);
    Rcpp::traits::input_parameter< const double >::type sigma_theta(sigma_thetaSEXP);
    Rcpp::traits::input_parameter< const double >::type sigma_theta_tilde(sigma_theta_tildeSEXP);
    Rcpp::traits::input_parameter< const double >::type eta(etaSEXP);
    rcpp_result_gen = Rcpp::wrap(SMI_pred_biased_data(Z, Y, sigma_z, sigma_y, sigma_phi, sigma_theta, sigma_theta_tilde, eta));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _aistats2020smi_SMI_pred_biased_data(SEXP ZSEXP, SEXP YSEXP, SEXP sigma_zSEXP, SEXP sigma_ySEXP, SEXP sigma_phiSEXP, SEXP sigma_thetaSEXP, SEXP sigma_theta_tildeSEXP, SEXP etaSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_aistats2020smi_SMI_pred_biased_data_try(ZSEXP, YSEXP, sigma_zSEXP, sigma_ySEXP, sigma_phiSEXP, sigma_thetaSEXP, sigma_theta_tildeSEXP, etaSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// dmvnorm_arma
arma::vec dmvnorm_arma(arma::mat x, arma::rowvec mean, arma::mat sigma, bool logd);
static SEXP _aistats2020smi_dmvnorm_arma_try(SEXP xSEXP, SEXP meanSEXP, SEXP sigmaSEXP, SEXP logdSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< arma::mat >::type x(xSEXP);
    Rcpp::traits::input_parameter< arma::rowvec >::type mean(meanSEXP);
    Rcpp::traits::input_parameter< arma::mat >::type sigma(sigmaSEXP);
    Rcpp::traits::input_parameter< bool >::type logd(logdSEXP);
    rcpp_result_gen = Rcpp::wrap(dmvnorm_arma(x, mean, sigma, logd));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _aistats2020smi_dmvnorm_arma(SEXP xSEXP, SEXP meanSEXP, SEXP sigmaSEXP, SEXP logdSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_aistats2020smi_dmvnorm_arma_try(xSEXP, meanSEXP, sigmaSEXP, logdSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// categ_to_dummie
arma::mat categ_to_dummie(const arma::vec x, const arma::vec categ_x);
static SEXP _aistats2020smi_categ_to_dummie_try(SEXP xSEXP, SEXP categ_xSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::vec >::type x(xSEXP);
    Rcpp::traits::input_parameter< const arma::vec >::type categ_x(categ_xSEXP);
    rcpp_result_gen = Rcpp::wrap(categ_to_dummie(x, categ_x));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _aistats2020smi_categ_to_dummie(SEXP xSEXP, SEXP categ_xSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_aistats2020smi_categ_to_dummie_try(xSEXP, categ_xSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// sign
double sign(const double val);
static SEXP _aistats2020smi_sign_try(SEXP valSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const double >::type val(valSEXP);
    rcpp_result_gen = Rcpp::wrap(sign(val));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _aistats2020smi_sign(SEXP valSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_aistats2020smi_sign_try(valSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// bounce_limit
double bounce_limit(double x, const double a, const double b);
static SEXP _aistats2020smi_bounce_limit_try(SEXP xSEXP, SEXP aSEXP, SEXP bSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< double >::type x(xSEXP);
    Rcpp::traits::input_parameter< const double >::type a(aSEXP);
    Rcpp::traits::input_parameter< const double >::type b(bSEXP);
    rcpp_result_gen = Rcpp::wrap(bounce_limit(x, a, b));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _aistats2020smi_bounce_limit(SEXP xSEXP, SEXP aSEXP, SEXP bSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_aistats2020smi_bounce_limit_try(xSEXP, aSEXP, bSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// dinvgamma
double dinvgamma(const double x, const double alpha, const double beta, const unsigned int lg);
static SEXP _aistats2020smi_dinvgamma_try(SEXP xSEXP, SEXP alphaSEXP, SEXP betaSEXP, SEXP lgSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const double >::type x(xSEXP);
    Rcpp::traits::input_parameter< const double >::type alpha(alphaSEXP);
    Rcpp::traits::input_parameter< const double >::type beta(betaSEXP);
    Rcpp::traits::input_parameter< const unsigned int >::type lg(lgSEXP);
    rcpp_result_gen = Rcpp::wrap(dinvgamma(x, alpha, beta, lg));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _aistats2020smi_dinvgamma(SEXP xSEXP, SEXP alphaSEXP, SEXP betaSEXP, SEXP lgSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_aistats2020smi_dinvgamma_try(xSEXP, alphaSEXP, betaSEXP, lgSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// mcmc_PO
Rcpp::List mcmc_PO(const arma::colvec Y, const arma::mat X, arma::mat X_eta, const unsigned int K, const double power_w, const std::string prior_spec, const bool rnd_eff, const unsigned int n_iter, arma::colvec theta, const arma::mat theta_min_max, arma::colvec theta_prop_int, const std::string theta_prop_kernel, const bool keep_ll, const bool check_mcmc, const bool verbose, const bool quiet);
static SEXP _aistats2020smi_mcmc_PO_try(SEXP YSEXP, SEXP XSEXP, SEXP X_etaSEXP, SEXP KSEXP, SEXP power_wSEXP, SEXP prior_specSEXP, SEXP rnd_effSEXP, SEXP n_iterSEXP, SEXP thetaSEXP, SEXP theta_min_maxSEXP, SEXP theta_prop_intSEXP, SEXP theta_prop_kernelSEXP, SEXP keep_llSEXP, SEXP check_mcmcSEXP, SEXP verboseSEXP, SEXP quietSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::colvec >::type Y(YSEXP);
    Rcpp::traits::input_parameter< const arma::mat >::type X(XSEXP);
    Rcpp::traits::input_parameter< arma::mat >::type X_eta(X_etaSEXP);
    Rcpp::traits::input_parameter< const unsigned int >::type K(KSEXP);
    Rcpp::traits::input_parameter< const double >::type power_w(power_wSEXP);
    Rcpp::traits::input_parameter< const std::string >::type prior_spec(prior_specSEXP);
    Rcpp::traits::input_parameter< const bool >::type rnd_eff(rnd_effSEXP);
    Rcpp::traits::input_parameter< const unsigned int >::type n_iter(n_iterSEXP);
    Rcpp::traits::input_parameter< arma::colvec >::type theta(thetaSEXP);
    Rcpp::traits::input_parameter< const arma::mat >::type theta_min_max(theta_min_maxSEXP);
    Rcpp::traits::input_parameter< arma::colvec >::type theta_prop_int(theta_prop_intSEXP);
    Rcpp::traits::input_parameter< const std::string >::type theta_prop_kernel(theta_prop_kernelSEXP);
    Rcpp::traits::input_parameter< const bool >::type keep_ll(keep_llSEXP);
    Rcpp::traits::input_parameter< const bool >::type check_mcmc(check_mcmcSEXP);
    Rcpp::traits::input_parameter< const bool >::type verbose(verboseSEXP);
    Rcpp::traits::input_parameter< const bool >::type quiet(quietSEXP);
    rcpp_result_gen = Rcpp::wrap(mcmc_PO(Y, X, X_eta, K, power_w, prior_spec, rnd_eff, n_iter, theta, theta_min_max, theta_prop_int, theta_prop_kernel, keep_ll, check_mcmc, verbose, quiet));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _aistats2020smi_mcmc_PO(SEXP YSEXP, SEXP XSEXP, SEXP X_etaSEXP, SEXP KSEXP, SEXP power_wSEXP, SEXP prior_specSEXP, SEXP rnd_effSEXP, SEXP n_iterSEXP, SEXP thetaSEXP, SEXP theta_min_maxSEXP, SEXP theta_prop_intSEXP, SEXP theta_prop_kernelSEXP, SEXP keep_llSEXP, SEXP check_mcmcSEXP, SEXP verboseSEXP, SEXP quietSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_aistats2020smi_mcmc_PO_try(YSEXP, XSEXP, X_etaSEXP, KSEXP, power_wSEXP, prior_specSEXP, rnd_effSEXP, n_iterSEXP, thetaSEXP, theta_min_maxSEXP, theta_prop_intSEXP, theta_prop_kernelSEXP, keep_llSEXP, check_mcmcSEXP, verboseSEXP, quietSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// mcmc_PO_HM_powered
Rcpp::List mcmc_PO_HM_powered(const arma::mat data_arc, const arma::mat data_mod, double power_w_PO, double power_w_HM, const std::string prior_spec_PO, const std::string prior_spec_HM, const bool PO_site_rnd_eff, const bool HM_site_rnd_eff, const unsigned int n_iter, const unsigned int n_warmup, const unsigned int n_thin, arma::colvec theta, const arma::mat theta_min_max, arma::colvec theta_prop_int, const std::string theta_prop_kernel, arma::colvec ManureLevel_imp, arma::colvec Rainfall_imp, const bool imp_playpen, const bool gibbs_hm, const bool keep_imp, const bool keep_ll, const bool check_mcmc, const bool verbose);
static SEXP _aistats2020smi_mcmc_PO_HM_powered_try(SEXP data_arcSEXP, SEXP data_modSEXP, SEXP power_w_POSEXP, SEXP power_w_HMSEXP, SEXP prior_spec_POSEXP, SEXP prior_spec_HMSEXP, SEXP PO_site_rnd_effSEXP, SEXP HM_site_rnd_effSEXP, SEXP n_iterSEXP, SEXP n_warmupSEXP, SEXP n_thinSEXP, SEXP thetaSEXP, SEXP theta_min_maxSEXP, SEXP theta_prop_intSEXP, SEXP theta_prop_kernelSEXP, SEXP ManureLevel_impSEXP, SEXP Rainfall_impSEXP, SEXP imp_playpenSEXP, SEXP gibbs_hmSEXP, SEXP keep_impSEXP, SEXP keep_llSEXP, SEXP check_mcmcSEXP, SEXP verboseSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::mat >::type data_arc(data_arcSEXP);
    Rcpp::traits::input_parameter< const arma::mat >::type data_mod(data_modSEXP);
    Rcpp::traits::input_parameter< double >::type power_w_PO(power_w_POSEXP);
    Rcpp::traits::input_parameter< double >::type power_w_HM(power_w_HMSEXP);
    Rcpp::traits::input_parameter< const std::string >::type prior_spec_PO(prior_spec_POSEXP);
    Rcpp::traits::input_parameter< const std::string >::type prior_spec_HM(prior_spec_HMSEXP);
    Rcpp::traits::input_parameter< const bool >::type PO_site_rnd_eff(PO_site_rnd_effSEXP);
    Rcpp::traits::input_parameter< const bool >::type HM_site_rnd_eff(HM_site_rnd_effSEXP);
    Rcpp::traits::input_parameter< const unsigned int >::type n_iter(n_iterSEXP);
    Rcpp::traits::input_parameter< const unsigned int >::type n_warmup(n_warmupSEXP);
    Rcpp::traits::input_parameter< const unsigned int >::type n_thin(n_thinSEXP);
    Rcpp::traits::input_parameter< arma::colvec >::type theta(thetaSEXP);
    Rcpp::traits::input_parameter< const arma::mat >::type theta_min_max(theta_min_maxSEXP);
    Rcpp::traits::input_parameter< arma::colvec >::type theta_prop_int(theta_prop_intSEXP);
    Rcpp::traits::input_parameter< const std::string >::type theta_prop_kernel(theta_prop_kernelSEXP);
    Rcpp::traits::input_parameter< arma::colvec >::type ManureLevel_imp(ManureLevel_impSEXP);
    Rcpp::traits::input_parameter< arma::colvec >::type Rainfall_imp(Rainfall_impSEXP);
    Rcpp::traits::input_parameter< const bool >::type imp_playpen(imp_playpenSEXP);
    Rcpp::traits::input_parameter< const bool >::type gibbs_hm(gibbs_hmSEXP);
    Rcpp::traits::input_parameter< const bool >::type keep_imp(keep_impSEXP);
    Rcpp::traits::input_parameter< const bool >::type keep_ll(keep_llSEXP);
    Rcpp::traits::input_parameter< const bool >::type check_mcmc(check_mcmcSEXP);
    Rcpp::traits::input_parameter< const bool >::type verbose(verboseSEXP);
    rcpp_result_gen = Rcpp::wrap(mcmc_PO_HM_powered(data_arc, data_mod, power_w_PO, power_w_HM, prior_spec_PO, prior_spec_HM, PO_site_rnd_eff, HM_site_rnd_eff, n_iter, n_warmup, n_thin, theta, theta_min_max, theta_prop_int, theta_prop_kernel, ManureLevel_imp, Rainfall_imp, imp_playpen, gibbs_hm, keep_imp, keep_ll, check_mcmc, verbose));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _aistats2020smi_mcmc_PO_HM_powered(SEXP data_arcSEXP, SEXP data_modSEXP, SEXP power_w_POSEXP, SEXP power_w_HMSEXP, SEXP prior_spec_POSEXP, SEXP prior_spec_HMSEXP, SEXP PO_site_rnd_effSEXP, SEXP HM_site_rnd_effSEXP, SEXP n_iterSEXP, SEXP n_warmupSEXP, SEXP n_thinSEXP, SEXP thetaSEXP, SEXP theta_min_maxSEXP, SEXP theta_prop_intSEXP, SEXP theta_prop_kernelSEXP, SEXP ManureLevel_impSEXP, SEXP Rainfall_impSEXP, SEXP imp_playpenSEXP, SEXP gibbs_hmSEXP, SEXP keep_impSEXP, SEXP keep_llSEXP, SEXP check_mcmcSEXP, SEXP verboseSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_aistats2020smi_mcmc_PO_HM_powered_try(data_arcSEXP, data_modSEXP, power_w_POSEXP, power_w_HMSEXP, prior_spec_POSEXP, prior_spec_HMSEXP, PO_site_rnd_effSEXP, HM_site_rnd_effSEXP, n_iterSEXP, n_warmupSEXP, n_thinSEXP, thetaSEXP, theta_min_maxSEXP, theta_prop_intSEXP, theta_prop_kernelSEXP, ManureLevel_impSEXP, Rainfall_impSEXP, imp_playpenSEXP, gibbs_hmSEXP, keep_impSEXP, keep_llSEXP, check_mcmcSEXP, verboseSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// loglik_PO_i_cpp
arma::colvec loglik_PO_i_cpp(const arma::colvec Y, const arma::mat X, const arma::colvec alpha, const arma::colvec beta);
static SEXP _aistats2020smi_loglik_PO_i_cpp_try(SEXP YSEXP, SEXP XSEXP, SEXP alphaSEXP, SEXP betaSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::colvec >::type Y(YSEXP);
    Rcpp::traits::input_parameter< const arma::mat >::type X(XSEXP);
    Rcpp::traits::input_parameter< const arma::colvec >::type alpha(alphaSEXP);
    Rcpp::traits::input_parameter< const arma::colvec >::type beta(betaSEXP);
    rcpp_result_gen = Rcpp::wrap(loglik_PO_i_cpp(Y, X, alpha, beta));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _aistats2020smi_loglik_PO_i_cpp(SEXP YSEXP, SEXP XSEXP, SEXP alphaSEXP, SEXP betaSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_aistats2020smi_loglik_PO_i_cpp_try(YSEXP, XSEXP, alphaSEXP, betaSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// loglik_PO_cpp
double loglik_PO_cpp(const arma::colvec Y, const arma::mat X, const arma::colvec alpha, const arma::colvec beta);
static SEXP _aistats2020smi_loglik_PO_cpp_try(SEXP YSEXP, SEXP XSEXP, SEXP alphaSEXP, SEXP betaSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::colvec >::type Y(YSEXP);
    Rcpp::traits::input_parameter< const arma::mat >::type X(XSEXP);
    Rcpp::traits::input_parameter< const arma::colvec >::type alpha(alphaSEXP);
    Rcpp::traits::input_parameter< const arma::colvec >::type beta(betaSEXP);
    rcpp_result_gen = Rcpp::wrap(loglik_PO_cpp(Y, X, alpha, beta));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _aistats2020smi_loglik_PO_cpp(SEXP YSEXP, SEXP XSEXP, SEXP alphaSEXP, SEXP betaSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_aistats2020smi_loglik_PO_cpp_try(YSEXP, XSEXP, alphaSEXP, betaSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// logprior_PO_cpp
double logprior_PO_cpp(const arma::colvec alpha, const arma::colvec beta, const double sigma_eta, const arma::colvec eta, const std::string prior_spec);
static SEXP _aistats2020smi_logprior_PO_cpp_try(SEXP alphaSEXP, SEXP betaSEXP, SEXP sigma_etaSEXP, SEXP etaSEXP, SEXP prior_specSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::colvec >::type alpha(alphaSEXP);
    Rcpp::traits::input_parameter< const arma::colvec >::type beta(betaSEXP);
    Rcpp::traits::input_parameter< const double >::type sigma_eta(sigma_etaSEXP);
    Rcpp::traits::input_parameter< const arma::colvec >::type eta(etaSEXP);
    Rcpp::traits::input_parameter< const std::string >::type prior_spec(prior_specSEXP);
    rcpp_result_gen = Rcpp::wrap(logprior_PO_cpp(alpha, beta, sigma_eta, eta, prior_spec));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _aistats2020smi_logprior_PO_cpp(SEXP alphaSEXP, SEXP betaSEXP, SEXP sigma_etaSEXP, SEXP etaSEXP, SEXP prior_specSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_aistats2020smi_logprior_PO_cpp_try(alphaSEXP, betaSEXP, sigma_etaSEXP, etaSEXP, prior_specSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// loglik_HM_i_cpp
arma::colvec loglik_HM_i_cpp(const arma::colvec Y, const arma::mat X, const arma::colvec beta, const double sigma, const double v, const arma::colvec ind_v);
static SEXP _aistats2020smi_loglik_HM_i_cpp_try(SEXP YSEXP, SEXP XSEXP, SEXP betaSEXP, SEXP sigmaSEXP, SEXP vSEXP, SEXP ind_vSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::colvec >::type Y(YSEXP);
    Rcpp::traits::input_parameter< const arma::mat >::type X(XSEXP);
    Rcpp::traits::input_parameter< const arma::colvec >::type beta(betaSEXP);
    Rcpp::traits::input_parameter< const double >::type sigma(sigmaSEXP);
    Rcpp::traits::input_parameter< const double >::type v(vSEXP);
    Rcpp::traits::input_parameter< const arma::colvec >::type ind_v(ind_vSEXP);
    rcpp_result_gen = Rcpp::wrap(loglik_HM_i_cpp(Y, X, beta, sigma, v, ind_v));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _aistats2020smi_loglik_HM_i_cpp(SEXP YSEXP, SEXP XSEXP, SEXP betaSEXP, SEXP sigmaSEXP, SEXP vSEXP, SEXP ind_vSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_aistats2020smi_loglik_HM_i_cpp_try(YSEXP, XSEXP, betaSEXP, sigmaSEXP, vSEXP, ind_vSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// loglik_HM_cpp
double loglik_HM_cpp(const arma::colvec Y, const arma::mat X, const arma::colvec beta, const double sigma, const double v, const arma::colvec ind_v);
static SEXP _aistats2020smi_loglik_HM_cpp_try(SEXP YSEXP, SEXP XSEXP, SEXP betaSEXP, SEXP sigmaSEXP, SEXP vSEXP, SEXP ind_vSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::colvec >::type Y(YSEXP);
    Rcpp::traits::input_parameter< const arma::mat >::type X(XSEXP);
    Rcpp::traits::input_parameter< const arma::colvec >::type beta(betaSEXP);
    Rcpp::traits::input_parameter< const double >::type sigma(sigmaSEXP);
    Rcpp::traits::input_parameter< const double >::type v(vSEXP);
    Rcpp::traits::input_parameter< const arma::colvec >::type ind_v(ind_vSEXP);
    rcpp_result_gen = Rcpp::wrap(loglik_HM_cpp(Y, X, beta, sigma, v, ind_v));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _aistats2020smi_loglik_HM_cpp(SEXP YSEXP, SEXP XSEXP, SEXP betaSEXP, SEXP sigmaSEXP, SEXP vSEXP, SEXP ind_vSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_aistats2020smi_loglik_HM_cpp_try(YSEXP, XSEXP, betaSEXP, sigmaSEXP, vSEXP, ind_vSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// logprior_HM_cpp
double logprior_HM_cpp(const arma::colvec beta, const double sigma, const double v, const double sigma_eta, const arma::colvec eta, const std::string prior_spec);
static SEXP _aistats2020smi_logprior_HM_cpp_try(SEXP betaSEXP, SEXP sigmaSEXP, SEXP vSEXP, SEXP sigma_etaSEXP, SEXP etaSEXP, SEXP prior_specSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::colvec >::type beta(betaSEXP);
    Rcpp::traits::input_parameter< const double >::type sigma(sigmaSEXP);
    Rcpp::traits::input_parameter< const double >::type v(vSEXP);
    Rcpp::traits::input_parameter< const double >::type sigma_eta(sigma_etaSEXP);
    Rcpp::traits::input_parameter< const arma::colvec >::type eta(etaSEXP);
    Rcpp::traits::input_parameter< const std::string >::type prior_spec(prior_specSEXP);
    rcpp_result_gen = Rcpp::wrap(logprior_HM_cpp(beta, sigma, v, sigma_eta, eta, prior_spec));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _aistats2020smi_logprior_HM_cpp(SEXP betaSEXP, SEXP sigmaSEXP, SEXP vSEXP, SEXP sigma_etaSEXP, SEXP etaSEXP, SEXP prior_specSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_aistats2020smi_logprior_HM_cpp_try(betaSEXP, sigmaSEXP, vSEXP, sigma_etaSEXP, etaSEXP, prior_specSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}

// validate (ensure exported C++ functions exist before calling them)
static int _aistats2020smi_RcppExport_validate(const char* sig) { 
    static std::set<std::string> signatures;
    if (signatures.empty()) {
        signatures.insert("Rcpp::List(*SMI_post_biased_data)(const arma::vec,const arma::vec,const double,const double,const double,const double,const double,const double)");
        signatures.insert("Rcpp::List(*SMI_pred_biased_data)(const arma::vec,const arma::vec,const double,const double,const double,const double,const double,const double)");
        signatures.insert("arma::vec(*dmvnorm_arma)(arma::mat,arma::rowvec,arma::mat,bool)");
        signatures.insert("arma::mat(*categ_to_dummie)(const arma::vec,const arma::vec)");
        signatures.insert("double(*sign)(const double)");
        signatures.insert("double(*bounce_limit)(double,const double,const double)");
        signatures.insert("double(*dinvgamma)(const double,const double,const double,const unsigned int)");
        signatures.insert("Rcpp::List(*mcmc_PO)(const arma::colvec,const arma::mat,arma::mat,const unsigned int,const double,const std::string,const bool,const unsigned int,arma::colvec,const arma::mat,arma::colvec,const std::string,const bool,const bool,const bool,const bool)");
        signatures.insert("Rcpp::List(*mcmc_PO_HM_powered)(const arma::mat,const arma::mat,double,double,const std::string,const std::string,const bool,const bool,const unsigned int,const unsigned int,const unsigned int,arma::colvec,const arma::mat,arma::colvec,const std::string,arma::colvec,arma::colvec,const bool,const bool,const bool,const bool,const bool,const bool)");
        signatures.insert("arma::colvec(*loglik_PO_i_cpp)(const arma::colvec,const arma::mat,const arma::colvec,const arma::colvec)");
        signatures.insert("double(*loglik_PO_cpp)(const arma::colvec,const arma::mat,const arma::colvec,const arma::colvec)");
        signatures.insert("double(*logprior_PO_cpp)(const arma::colvec,const arma::colvec,const double,const arma::colvec,const std::string)");
        signatures.insert("arma::colvec(*loglik_HM_i_cpp)(const arma::colvec,const arma::mat,const arma::colvec,const double,const double,const arma::colvec)");
        signatures.insert("double(*loglik_HM_cpp)(const arma::colvec,const arma::mat,const arma::colvec,const double,const double,const arma::colvec)");
        signatures.insert("double(*logprior_HM_cpp)(const arma::colvec,const double,const double,const double,const arma::colvec,const std::string)");
    }
    return signatures.find(sig) != signatures.end();
}

// registerCCallable (register entry points for exported C++ functions)
RcppExport SEXP _aistats2020smi_RcppExport_registerCCallable() { 
    R_RegisterCCallable("aistats2020smi", "_aistats2020smi_SMI_post_biased_data", (DL_FUNC)_aistats2020smi_SMI_post_biased_data_try);
    R_RegisterCCallable("aistats2020smi", "_aistats2020smi_SMI_pred_biased_data", (DL_FUNC)_aistats2020smi_SMI_pred_biased_data_try);
    R_RegisterCCallable("aistats2020smi", "_aistats2020smi_dmvnorm_arma", (DL_FUNC)_aistats2020smi_dmvnorm_arma_try);
    R_RegisterCCallable("aistats2020smi", "_aistats2020smi_categ_to_dummie", (DL_FUNC)_aistats2020smi_categ_to_dummie_try);
    R_RegisterCCallable("aistats2020smi", "_aistats2020smi_sign", (DL_FUNC)_aistats2020smi_sign_try);
    R_RegisterCCallable("aistats2020smi", "_aistats2020smi_bounce_limit", (DL_FUNC)_aistats2020smi_bounce_limit_try);
    R_RegisterCCallable("aistats2020smi", "_aistats2020smi_dinvgamma", (DL_FUNC)_aistats2020smi_dinvgamma_try);
    R_RegisterCCallable("aistats2020smi", "_aistats2020smi_mcmc_PO", (DL_FUNC)_aistats2020smi_mcmc_PO_try);
    R_RegisterCCallable("aistats2020smi", "_aistats2020smi_mcmc_PO_HM_powered", (DL_FUNC)_aistats2020smi_mcmc_PO_HM_powered_try);
    R_RegisterCCallable("aistats2020smi", "_aistats2020smi_loglik_PO_i_cpp", (DL_FUNC)_aistats2020smi_loglik_PO_i_cpp_try);
    R_RegisterCCallable("aistats2020smi", "_aistats2020smi_loglik_PO_cpp", (DL_FUNC)_aistats2020smi_loglik_PO_cpp_try);
    R_RegisterCCallable("aistats2020smi", "_aistats2020smi_logprior_PO_cpp", (DL_FUNC)_aistats2020smi_logprior_PO_cpp_try);
    R_RegisterCCallable("aistats2020smi", "_aistats2020smi_loglik_HM_i_cpp", (DL_FUNC)_aistats2020smi_loglik_HM_i_cpp_try);
    R_RegisterCCallable("aistats2020smi", "_aistats2020smi_loglik_HM_cpp", (DL_FUNC)_aistats2020smi_loglik_HM_cpp_try);
    R_RegisterCCallable("aistats2020smi", "_aistats2020smi_logprior_HM_cpp", (DL_FUNC)_aistats2020smi_logprior_HM_cpp_try);
    R_RegisterCCallable("aistats2020smi", "_aistats2020smi_RcppExport_validate", (DL_FUNC)_aistats2020smi_RcppExport_validate);
    return R_NilValue;
}

static const R_CallMethodDef CallEntries[] = {
    {"_aistats2020smi_SMI_post_biased_data", (DL_FUNC) &_aistats2020smi_SMI_post_biased_data, 8},
    {"_aistats2020smi_SMI_pred_biased_data", (DL_FUNC) &_aistats2020smi_SMI_pred_biased_data, 8},
    {"_aistats2020smi_dmvnorm_arma", (DL_FUNC) &_aistats2020smi_dmvnorm_arma, 4},
    {"_aistats2020smi_categ_to_dummie", (DL_FUNC) &_aistats2020smi_categ_to_dummie, 2},
    {"_aistats2020smi_sign", (DL_FUNC) &_aistats2020smi_sign, 1},
    {"_aistats2020smi_bounce_limit", (DL_FUNC) &_aistats2020smi_bounce_limit, 3},
    {"_aistats2020smi_dinvgamma", (DL_FUNC) &_aistats2020smi_dinvgamma, 4},
    {"_aistats2020smi_mcmc_PO", (DL_FUNC) &_aistats2020smi_mcmc_PO, 16},
    {"_aistats2020smi_mcmc_PO_HM_powered", (DL_FUNC) &_aistats2020smi_mcmc_PO_HM_powered, 23},
    {"_aistats2020smi_loglik_PO_i_cpp", (DL_FUNC) &_aistats2020smi_loglik_PO_i_cpp, 4},
    {"_aistats2020smi_loglik_PO_cpp", (DL_FUNC) &_aistats2020smi_loglik_PO_cpp, 4},
    {"_aistats2020smi_logprior_PO_cpp", (DL_FUNC) &_aistats2020smi_logprior_PO_cpp, 5},
    {"_aistats2020smi_loglik_HM_i_cpp", (DL_FUNC) &_aistats2020smi_loglik_HM_i_cpp, 6},
    {"_aistats2020smi_loglik_HM_cpp", (DL_FUNC) &_aistats2020smi_loglik_HM_cpp, 6},
    {"_aistats2020smi_logprior_HM_cpp", (DL_FUNC) &_aistats2020smi_logprior_HM_cpp, 6},
    {"_aistats2020smi_RcppExport_registerCCallable", (DL_FUNC) &_aistats2020smi_RcppExport_registerCCallable, 0},
    {NULL, NULL, 0}
};

RcppExport void R_init_aistats2020smi(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
